package testdata;


// This file was generated by colf(1); DO NOT EDIT


import static java.lang.String.format;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.InputMismatchException;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;


/**
 * Data bean with built-in serialization support.
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class O implements java.io.Serializable {

	/** The upper limit for serial byte sizes. */
	public static int colferSizeMax = 16 * 1024 * 1024;

	/** The upper limit for the number of elements in a list. */
	public static int colferListMax = 64 * 1024;
	private static final byte[] _zeroA = new byte[0];
	private static final O[] _zeroOs = new O[0];
	private static final String[] _zeroSs = new String[0];

	public boolean b;
	public int u32;
	public long u64;
	public int i32;
	public long i64;
	public float f32;
	public double f64;
	public java.time.Instant t;
	public String s = "";
	public byte[] a = _zeroA;
	public O o;
	public O[] os = _zeroOs;
	public String[] ss = _zeroSs;


	/**
	 * {@link #reset(InputStream) Reusable} deserialization of Colfer streams.
	 */
	public static class Unmarshaller {

		/** The data source. */
		protected InputStream in;

		/** The read buffer. */
		protected byte[] buf;

		/** The {@link #buf buffer}'s data start index, inclusive. */
		protected int offset;

		/** The {@link #buf buffer}'s data end index, exclusive. */
		protected int i;


		/**
		 * @param in the data source or {@code null}.
		 * @param buf the initial buffer or {@code null}.
		 */
		public Unmarshaller(InputStream in, byte[] buf) {
			if (buf == null || buf.length == 0)
				buf = new byte[Math.min(O.colferSizeMax, 2048)];
			this.buf = buf;
			reset(in);
		}

		/**
		 * Reuses the marshaller.
		 * @param in the data source or {@code null}.
		 * @throws IllegalStateException on pending data.
		 */
		public void reset(InputStream in) {
			if (this.i != this.offset) throw new IllegalStateException("colfer: pending data");
			this.in = in;
			this.offset = 0;
			this.i = 0;
		}

		/**
		 * Deserializes the following object.
		 * @return the result or {@code null} when EOF.
		 * @throws IOException from the input stream.
		 * @throws SecurityException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
		 * @throws InputMismatchException when the data does not match this object's schema.
		 */
		public O next() throws IOException {
			if (in == null) return null;

			while (true) {
				if (this.i > this.offset) {
					try {
						O o = new O();
						this.offset = o.unmarshal(this.buf, this.offset, this.i);
						return o;
					} catch (BufferUnderflowException e) {
					}
				}
				// not enough data

				if (this.i <= this.offset) {
					this.offset = 0;
					this.i = 0;
				} else if (i == buf.length) {
					byte[] src = this.buf;
					if (offset == 0) this.buf = new byte[Math.min(O.colferSizeMax, this.buf.length * 4)];
					System.arraycopy(src, this.offset, this.buf, 0, this.i - this.offset);
					this.i -= this.offset;
					this.offset = 0;
				}
				assert this.i < this.buf.length;

				int n = in.read(buf, i, buf.length - i);
				if (n < 0) {
					if (this.i > this.offset)
						throw new InputMismatchException("colfer: pending data with EOF");
					return null;
				}
				assert n > 0;
				i += n;
			}
		}

	}


	/**
	 * Serializes the object.
	 * All {@code null} elements in {@link #os} will be replaced with a {@code new} value.
	 * All {@code null} elements in {@link #ss} will be replaced with {@code ""}.
	 * @param out the data destination.
	 * @param buf the initial buffer or {@code null}.
	 * @return the final buffer. When the serial fits into {@code buf} then the return is {@code buf}.
	 *  Otherwise the return is a new buffer, large enough to hold the whole serial.
	 * @throws IOException from {@code out}.
	 * @throws IllegalStateException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 */
	public byte[] marshal(OutputStream out, byte[] buf) throws IOException {
		if (buf == null || buf.length == 0)
			buf = new byte[Math.min(O.colferSizeMax, 2048)];

		while (true) {
			int i;
			try {
				i = marshal(buf, 0);
			} catch (BufferOverflowException e) {
				buf = new byte[Math.min(O.colferSizeMax, buf.length * 4)];
				continue;
			}

			out.write(buf, 0, i);
			return buf;
		}
	}

	/**
	 * Serializes the object.
	 * All {@code null} elements in {@link #os} will be replaced with a {@code new} value.
	 * All {@code null} elements in {@link #ss} will be replaced with {@code ""}.
	 * @param buf the data destination.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferOverflowException when {@code buf} is too small.
	 * @throws IllegalStateException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 */
	public int marshal(byte[] buf, int offset) {
		int i = offset;

		try {
			if (this.b) {
				buf[i++] = (byte) 0;
			}

			if (this.u32 != 0) {
				int x = this.u32;
				if ((x & ~((1 << 21) - 1)) != 0) {
					buf[i++] = (byte) (1 | 0x80);
					buf[i++] = (byte) (x >>> 24);
					buf[i++] = (byte) (x >>> 16);
					buf[i++] = (byte) (x >>> 8);
					buf[i++] = (byte) (x);
				} else {
					buf[i++] = (byte) 1;
					while (x > 0x7f) {
						buf[i++] = (byte) (x | 0x80);
						x >>>= 7;
					}
					buf[i++] = (byte) x;
				}
			}

			if (this.u64 != 0) {
				long x = this.u64;
				if ((x & ~((1 << 49) - 1)) != 0) {
					buf[i++] = (byte) (2 | 0x80);
					buf[i++] = (byte) (x >>> 56);
					buf[i++] = (byte) (x >>> 48);
					buf[i++] = (byte) (x >>> 40);
					buf[i++] = (byte) (x >>> 32);
					buf[i++] = (byte) (x >>> 24);
					buf[i++] = (byte) (x >>> 16);
					buf[i++] = (byte) (x >>> 8);
					buf[i++] = (byte) (x);
				} else {
					buf[i++] = (byte) 2;
					while (x > 0x7fL) {
						buf[i++] = (byte) (x | 0x80);
						x >>>= 7;
					}
					buf[i++] = (byte) x;
				}
			}

			if (this.i32 != 0) {
				int x = this.i32;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (3 | 0x80);
				} else
					buf[i++] = (byte) 3;
				while ((x & ~0x7f) != 0) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (this.i64 != 0) {
				long x = this.i64;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (4 | 0x80);
				} else
					buf[i++] = (byte) 4;
				for (int n = 0; n < 8 && (x & ~0x7fL) != 0; n++) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (this.f32 != 0.0f) {
				buf[i++] = (byte) 5;
				int x = Float.floatToRawIntBits(this.f32);
				buf[i++] = (byte) (x >>> 24);
				buf[i++] = (byte) (x >>> 16);
				buf[i++] = (byte) (x >>> 8);
				buf[i++] = (byte) (x);
			}

			if (this.f64 != 0.0) {
				buf[i++] = (byte) 6;
				long x = Double.doubleToRawLongBits(this.f64);
				buf[i++] = (byte) (x >>> 56);
				buf[i++] = (byte) (x >>> 48);
				buf[i++] = (byte) (x >>> 40);
				buf[i++] = (byte) (x >>> 32);
				buf[i++] = (byte) (x >>> 24);
				buf[i++] = (byte) (x >>> 16);
				buf[i++] = (byte) (x >>> 8);
				buf[i++] = (byte) (x);
			}

			if (this.t != null) {
				long s = this.t.getEpochSecond();
				int ns = this.t.getNano();
				if (s != 0 || ns != 0) {
					if (s >= 0 && s < (1L << 32)) {
						buf[i++] = (byte) 7;
						buf[i++] = (byte) (s >>> 24);
						buf[i++] = (byte) (s >>> 16);
						buf[i++] = (byte) (s >>> 8);
						buf[i++] = (byte) (s);
						buf[i++] = (byte) (ns >>> 24);
						buf[i++] = (byte) (ns >>> 16);
						buf[i++] = (byte) (ns >>> 8);
						buf[i++] = (byte) (ns);
					} else {
						buf[i++] = (byte) (7 | 0x80);
						buf[i++] = (byte) (s >>> 56);
						buf[i++] = (byte) (s >>> 48);
						buf[i++] = (byte) (s >>> 40);
						buf[i++] = (byte) (s >>> 32);
						buf[i++] = (byte) (s >>> 24);
						buf[i++] = (byte) (s >>> 16);
						buf[i++] = (byte) (s >>> 8);
						buf[i++] = (byte) (s);
						buf[i++] = (byte) (ns >>> 24);
						buf[i++] = (byte) (ns >>> 16);
						buf[i++] = (byte) (ns >>> 8);
						buf[i++] = (byte) (ns);
					}
				}
			}

			if (! this.s.isEmpty()) {
				buf[i++] = (byte) 8;
				int start = ++i;

				String s = this.s;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > O.colferSizeMax)
					throw new IllegalStateException(format("colfer: field testdata.o.s size %d exceeds %d UTF-8 bytes", size, O.colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (this.a.length != 0) {
				buf[i++] = (byte) 9;

				int size = this.a.length;
				if (size > O.colferSizeMax)
					throw new IllegalStateException(format("colfer: field testdata.o.a size %d exceeds %d bytes", size, O.colferSizeMax));

				int x = size;
				while (x > 0x7f) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;

				int start = i;
				i += size;
				System.arraycopy(this.a, 0, buf, start, size);
			}

			if (this.o != null) {
				buf[i++] = (byte) 10;
				i = this.o.marshal(buf, i);
			}

			if (this.os.length != 0) {
				buf[i++] = (byte) 11;
				O[] a = this.os;

				int x = a.length;
				if (x > O.colferListMax)
					throw new IllegalStateException(format("colfer: field testdata.o.os length %d exceeds %d elements", x, O.colferListMax));
				while (x > 0x7f) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;

				for (int ai = 0; ai < a.length; ai++) {
					O o = a[ai];
					if (o == null) {
						o = new O();
						a[ai] = o;
					}
					i = o.marshal(buf, i);
				}
			}

			if (this.ss.length != 0) {
				buf[i++] = (byte) 12;
				String[] a = this.ss;

				int x = a.length;
				if (x > O.colferListMax)
					throw new IllegalStateException(format("colfer: field testdata.o.ss length %d exceeds %d elements", x, O.colferListMax));
				while (x > 0x7f) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;

				for (int ai = 0; ai < a.length; ai++) {
					String s = a[ai];
					if (s == null) {
						s = "";
						a[ai] = s;
					}

					int start = ++i;

					for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
						char c = s.charAt(sIndex);
						if (c < '\u0080') {
							buf[i++] = (byte) c;
						} else if (c < '\u0800') {
							buf[i++] = (byte) (192 | c >>> 6);
							buf[i++] = (byte) (128 | c & 63);
						} else if (c < '\ud800' || c > '\udfff') {
							buf[i++] = (byte) (224 | c >>> 12);
							buf[i++] = (byte) (128 | c >>> 6 & 63);
							buf[i++] = (byte) (128 | c & 63);
						} else {
							int cp = 0;
							if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
							if ((cp >= 1 << 16) && (cp < 1 << 21)) {
								buf[i++] = (byte) (240 | cp >>> 18);
								buf[i++] = (byte) (128 | cp >>> 12 & 63);
								buf[i++] = (byte) (128 | cp >>> 6 & 63);
								buf[i++] = (byte) (128 | cp & 63);
							} else
								buf[i++] = (byte) '?';
						}
					}
					int size = i - start;
					if (size > O.colferSizeMax)
						throw new IllegalStateException(format("colfer: field testdata.o.ss size %d exceeds %d UTF-8 bytes", size, O.colferSizeMax));

					int ii = start - 1;
					if (size > 0x7f) {
						i++;
						for (int y = size; y >= 1 << 14; y >>>= 7) i++;
						System.arraycopy(buf, start, buf, i - size, size);

						do {
							buf[ii++] = (byte) (size | 0x80);
							size >>>= 7;
						} while (size > 0x7f);
					}
					buf[ii] = (byte) size;
				}
			}

			buf[i++] = (byte) 0x7f;
			return i;
		} catch (ArrayIndexOutOfBoundsException e) {
			if (i - offset > O.colferSizeMax)
				throw new IllegalStateException(format("colfer: serial exceeds %d bytes", O.colferSizeMax));
			if (i > buf.length) throw new BufferOverflowException();
			throw e;
		}
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset) {
		return unmarshal(buf, offset, buf.length);
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @param end the index limit for {@code buf}, exclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset, int end) {
		if (end > buf.length) end = buf.length;
		int i = offset;

		try {
			byte header = buf[i++];

			if (header == (byte) 0) {
				this.b = true;
				header = buf[i++];
			}

			if (header == (byte) 1) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.u32 = x;
				header = buf[i++];
			} else if (header == (byte) (1 | 0x80)) {
				this.u32 = (buf[i++] & 0xff) << 24 | (buf[i++] & 0xff) << 16 | (buf[i++] & 0xff) << 8 | (buf[i++] & 0xff);
				header = buf[i++];
			}

			if (header == (byte) 2) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.u64 = x;
				header = buf[i++];
			} else if (header == (byte) (2 | 0x80)) {
				this.u64 = (buf[i++] & 0xffL) << 56 | (buf[i++] & 0xffL) << 48 | (buf[i++] & 0xffL) << 40 | (buf[i++] & 0xffL) << 32
					| (buf[i++] & 0xffL) << 24 | (buf[i++] & 0xffL) << 16 | (buf[i++] & 0xffL) << 8 | (buf[i++] & 0xffL);
				header = buf[i++];
			}

			if (header == (byte) 3) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.i32 = x;
				header = buf[i++];
			} else if (header == (byte) (3 | 0x80)) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.i32 = -x;
				header = buf[i++];
			}

			if (header == (byte) 4) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.i64 = x;
				header = buf[i++];
			} else if (header == (byte) (4 | 0x80)) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.i64 = -x;
				header = buf[i++];
			}

			if (header == (byte) 5) {
				int x = (buf[i++] & 0xff) << 24 | (buf[i++] & 0xff) << 16 | (buf[i++] & 0xff) << 8 | (buf[i++] & 0xff);
				this.f32 = Float.intBitsToFloat(x);
				header = buf[i++];
			}

			if (header == (byte) 6) {
				long x = (buf[i++] & 0xffL) << 56 | (buf[i++] & 0xffL) << 48 | (buf[i++] & 0xffL) << 40 | (buf[i++] & 0xffL) << 32
					| (buf[i++] & 0xffL) << 24 | (buf[i++] & 0xffL) << 16 | (buf[i++] & 0xffL) << 8 | (buf[i++] & 0xffL);
				this.f64 = Double.longBitsToDouble(x);
				header = buf[i++];
			}

			if (header == (byte) 7) {
				long s = (buf[i++] & 0xffL) << 24 | (buf[i++] & 0xffL) << 16 | (buf[i++] & 0xffL) << 8 | (buf[i++] & 0xffL);
				long ns = (buf[i++] & 0xffL) << 24 | (buf[i++] & 0xffL) << 16 | (buf[i++] & 0xffL) << 8 | (buf[i++] & 0xffL);
				this.t = java.time.Instant.ofEpochSecond(s, ns);
				header = buf[i++];
			} else if (header == (byte) (7 | 0x80)) {
				long s = (buf[i++] & 0xffL) << 56 | (buf[i++] & 0xffL) << 48 | (buf[i++] & 0xffL) << 40 | (buf[i++] & 0xffL) << 32
					| (buf[i++] & 0xffL) << 24 | (buf[i++] & 0xffL) << 16 | (buf[i++] & 0xffL) << 8 | (buf[i++] & 0xffL);
				long ns = (buf[i++] & 0xffL) << 24 | (buf[i++] & 0xffL) << 16 | (buf[i++] & 0xffL) << 8 | (buf[i++] & 0xffL);
				this.t = java.time.Instant.ofEpochSecond(s, ns);
				header = buf[i++];
			}

			if (header == (byte) 8) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > O.colferSizeMax)
					throw new SecurityException(format("colfer: field testdata.o.s size %d exceeds %d UTF-8 bytes", size, O.colferSizeMax));

				int start = i;
				i += size;
				this.s = new String(buf, start, size, StandardCharsets.UTF_8);
				header = buf[i++];
			}

			if (header == (byte) 9) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > O.colferSizeMax)
					throw new SecurityException(format("colfer: field testdata.o.a size %d exceeds %d bytes", size, O.colferSizeMax));

				this.a = new byte[size];
				int start = i;
				i += size;
				System.arraycopy(buf, start, this.a, 0, size);
				header = buf[i++];
			}

			if (header == (byte) 10) {
				this.o = new O();
				i = this.o.unmarshal(buf, i, end);
				header = buf[i++];
			}

			if (header == (byte) 11) {
				int length = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					length |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (length > O.colferListMax)
					throw new SecurityException(format("colfer: field testdata.o.os length %d exceeds %d elements", length, O.colferListMax));

				O[] a = new O[length];
				for (int ai = 0; ai < length; ai++) {
					O o = new O();
					i = o.unmarshal(buf, i, end);
					a[ai] = o;
				}
				this.os = a;
				header = buf[i++];
			}

			if (header == (byte) 12) {
				int length = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					length |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (length > O.colferListMax)
					throw new SecurityException(format("colfer: field testdata.o.ss length %d exceeds %d elements", length, O.colferListMax));

				String[] a = new String[length];
				for (int ai = 0; ai < length; ai++) {
					int size = 0;
					for (int shift = 0; true; shift += 7) {
						byte b = buf[i++];
						size |= (b & 0x7f) << shift;
						if (shift == 28 || b >= 0) break;
					}
					if (size > O.colferSizeMax)
						throw new SecurityException(format("colfer: field testdata.o.ss size %d exceeds %d UTF-8 bytes", size, O.colferSizeMax));

					int start = i;
					i += size;
					a[ai] = new String(buf, start, size, StandardCharsets.UTF_8);
				}
				this.ss = a;
				header = buf[i++];
			}

			if (header != (byte) 0x7f)
				throw new InputMismatchException(format("colfer: unknown header at byte %d", i - 1));
		} finally {
			if (i > end && end - offset < O.colferSizeMax) throw new BufferUnderflowException();
			if (i - offset > O.colferSizeMax)
				throw new SecurityException(format("colfer: serial exceeds %d bytes", O.colferSizeMax));
			if (i > end) throw new BufferUnderflowException();
		}

		return i;
	}

	public boolean getB() {
		return this.b;
	}

	public void setB(boolean value) {
		this.b = value;
	}

	public int getU32() {
		return this.u32;
	}

	public void setU32(int value) {
		this.u32 = value;
	}

	public long getU64() {
		return this.u64;
	}

	public void setU64(long value) {
		this.u64 = value;
	}

	public int getI32() {
		return this.i32;
	}

	public void setI32(int value) {
		this.i32 = value;
	}

	public long getI64() {
		return this.i64;
	}

	public void setI64(long value) {
		this.i64 = value;
	}

	public float getF32() {
		return this.f32;
	}

	public void setF32(float value) {
		this.f32 = value;
	}

	public double getF64() {
		return this.f64;
	}

	public void setF64(double value) {
		this.f64 = value;
	}

	public java.time.Instant getT() {
		return this.t;
	}

	public void setT(java.time.Instant value) {
		this.t = value;
	}

	public String getS() {
		return this.s;
	}

	public void setS(String value) {
		this.s = value;
	}

	public byte[] getA() {
		return this.a;
	}

	public void setA(byte[] value) {
		this.a = value;
	}

	public O getO() {
		return this.o;
	}

	public void setO(O value) {
		this.o = value;
	}

	public O[] getOs() {
		return this.os;
	}

	public void setOs(O[] value) {
		this.os = value;
	}

	public String[] getSs() {
		return this.ss;
	}

	public void setSs(String[] value) {
		this.ss = value;
	}

	@Override
	public final int hashCode() {
		int h = 1;
		h = 31 * h + (this.b ? 1231 : 1237);
		h = 31 * h + this.u32;
		h = 31 * h + (int)(this.u64 ^ this.u64 >>> 32);
		h = 31 * h + this.i32;
		h = 31 * h + (int)(this.i64 ^ this.i64 >>> 32);
		h = 31 * h + Float.floatToIntBits(this.f32);
		long _f64Bits = Double.doubleToLongBits(this.f64);
		h = 31 * h + (int) (_f64Bits ^ _f64Bits >>> 32);
		if (this.t != null) h = 31 * h + this.t.hashCode();
		if (this.s != null) h = 31 * h + this.s.hashCode();
		for (byte b : this.a) h = 31 * h + b;
		if (this.o != null) h = 31 * h + this.o.hashCode();
		for (O o : this.os) h = 31 * h + (o == null ? 0 : o.hashCode());
		for (String o : this.ss) h = 31 * h + (o == null ? 0 : o.hashCode());
		return h;
	}

	@Override
	public final boolean equals(Object o) {
		return o instanceof O && equals((O) o);
	}

	public final boolean equals(O o) {
		return o != null && o.getClass() == O.class
			&& this.b == o.b
			&& this.u32 == o.u32
			&& this.u64 == o.u64
			&& this.i32 == o.i32
			&& this.i64 == o.i64
			&& (this.f32 == o.f32 || (this.f32 != this.f32 && o.f32 != o.f32))
			&& (this.f64 == o.f64 || (this.f64 != this.f64 && o.f64 != o.f64))
			&& this.t == null ? o.t == null : this.t.equals(o.t)
			&& this.s == null ? o.s == null : this.s.equals(o.s)
			&& java.util.Arrays.equals(this.a, o.a)
			&& this.o == null ? o.o == null : this.o.equals(o.o)
			&& java.util.Arrays.equals(this.os, o.os)
			&& java.util.Arrays.equals(this.ss, o.ss);
	}

}
